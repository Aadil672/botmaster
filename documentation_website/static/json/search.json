[
    {
        "uri": "/content/changelog/CHANGELOG",
        "title": "CHANGELOG",
        "content": "\nPATCH: Botmaster 2.1.1\n\nThis patch fixes a bug whereby one couldn't instantiate a botmaster object that would use socket.io in all reasonably expected ways. See here for a discussion.\n\n MINOR: Botmaster 2.1.0\n\nThis version adds support for socket.io bots within the botmaster core. This is the last\nbot class that will be in the core\n\nMAJOR: Botmaster 2.0.0\n\nIn this new version, a lot of new things were added to Botmaster. A few others were removed.\n\n Breaking Changes\nIf you were using SessionStore in version 1.x.x, you won't be able to anymore in version 2.x.x. They have been scratched for the far more common middleware design pattern common in so many other frameworks (e.g. express). Middleware can be hooked into right before receiving an update and right before sending out a message. It fits ideally with people wanting to setup session storage at these points.\n\nAdding Slack\nSupport for Slack as the fourth channel supported by Botmaster has been added. Using the Events API, you can now send and receive messages on the platform.\n\n get User info\nIf the platform supports it and the bot class you are using supports it too, you can now use the bot.getUserInfo method to retrieve basic information on a user, including their name and profile pic.\n\nbug fixes\nAs with any release, a bunch of bugfixes were done.\n",
        "tags": []
    },
    {
        "uri": "/content/getting-started/getting-set-up",
        "title": "Getting set up",
        "content": "\nIn order to instantiate a Botmaster object, you need to pass it some settings in the form of an object. These settings look like this.\n\nconst botmasterSettings = {\n  botsSettings: botsSettings, // see below for a definition of botsSettings\n  app: app, // optional, an express app object if you are running your own server\n  server: server, // optional, an http server object (used if using socket.io)\n  port: port, // optional, only used if \"app\" is not defined. Defaults t0 3000 in that case\n  sessionStore: sessionStore // optional. Define if you will be dealing with sessions\n}\nSee Working with Botmaster for a more formal definition\n\nbotsSettings look something like this:\n\nconst botsSettings = [{ messenger: messengerSettings },\n                      { twitter: twitterSettings },\n                      { twitter: otherTwitterSettings }];\n\nI.e. it is an array of single key objects. Where you specify the type as the key of each object and the settings as the value. Here I show that you can define multiple bots of the same type at once (twitter ones in this example). As you surely guessed, each different platform will expect different credentials. So platform specific settings will differ.\n\nOnce you have those botmasterSettings, you can go on and instantiate a Botmaster object. This looks something like this:\n\nconst botmaster = new Botmaster(botmasterSettings);\n\nNow, I know what you're thinking: \"but how do I get these messengerSettings and twitterSettings or other ones?\" Well, I cover all of those in the following pages.\n",
        "tags": []
    },
    {
        "uri": "/content/getting-started/index",
        "title": "Getting started",
        "content": "\nGETTING STARTED\n\n Installation\nQuickstart\n Getting set up\nMessenger Setup\n Slack Setup\nSocket.io Setup\n Twitter Setup\nTelegram setup\n",
        "tags": []
    },
    {
        "uri": "/content/getting-started/installation",
        "title": "Installation",
        "content": "\nMake sure you have Node.js and npm installed on your machine. If you don't, I recommend using nvm to manage your node versions. Find out more about it here\n\nOnce you have node, create a new project directory and go into it:\n\nmkdir mybotmasterproject && cd mybotmasterproject\n\nMake sure you initialize a node project in the new directory and going through the prompt by doing:\n\nnpm init\n\nFinally, install the botmaster npm package.\n\nnpm install --save botmaster\n\nThat should do!\n",
        "tags": []
    },
    {
        "uri": "/content/getting-started/messenger-setup",
        "title": "Facebook Messenger setup",
        "content": "\nCode\n\nconst Botmaster = require('botmaster');\n\nconst messengerSettings = {\n  credentials: {\n    verifyToken: 'YOUR verifyToken',\n    pageToken: 'YOUR pageToken',\n    fbAppSecret: 'YOUR fbAppSecret',\n  },\n  webhookEndpoint: '/webhook1234', // botmaster will mount this webhook on https://YourDomainName/messenger/webhook1234\n};\n\nconst botsSettings = [{ messenger: messengerSettings }];\n\nconst botmaster = new Botmaster({ botsSettings });\n\nbotmaster.on('update', (bot, update) = {\n  bot.reply(update, 'Right back at you');\n});\n\n Getting your Credentials\n\nIf you don't already have these, follow the steps 1-4 on the Facebook Messenger guide:\nhttps://developers.facebook.com/docs/messenger-platform/quickstart\n\nIn step 2, where you setup your webhook, no need to code anything. Just specify the webhook, enter any secure string you want as a verify token(verifyToken) and copy that value in the settings object. Also, click on whichever message [those are \"update\"s using botmaster semantics] type you want to receive from Messenger (messagedeliveries, messages, messagepostbacks etc...).\n\nTo find your Facebook App Secret (fbAppSecret), navigate to your apps dashboard and under App Secret click show, enter your password if prompted and then there it is.\n\nWebhooks\n\n{{% notice note %}}\nIf you are not too sure how webhooks work and/or how to get them to run locally, go to webhooks to read some more.\n{{% /notice %}}\n",
        "tags": []
    },
    {
        "uri": "/content/getting-started/quickstart",
        "title": "Quickstart",
        "content": "\nIf you already know your credentials for the platforms you want to be supporting in your project the following code will help you get started\n\n// settings stuff\nconst Botmaster = require('botmaster');\n\nconst messengerSettings = {\n  credentials: {\n    verifyToken: 'YOUR verifyToken',\n    pageToken: 'YOUR pageToken',\n    fbAppSecret: 'YOUR fbAppSecret',\n  },\n  webhookEndpoint: '/webhook1234', // botmaster will mount this webhook on https://YourDomainName/messenger/webhook1234\n};\n\nconst twitterSettings = {\n  credentials: {\n    consumerKey: 'YOUR consumerKey',\n    consumerSecret: 'YOUR consumerSecret',\n    accessToken: 'YOUR accessToken',\n    accessTokenSecret: 'YOUR accessTokenSecret',\n  }\n}\n\nconst telegramSettings = {\n  credentials: {\n    authToken: 'YOUR authToken',\n  },\n  webhookEndpoint: '/webhook1234/',\n};\n\nconst slackSettings = {\n  credentials: {\n    clientId: 'YOUR app client ID',\n    clientSecret: 'YOUR app client secret',\n    verificationToken: 'YOUR app verification Token',\n    landingPageURL: 'YOUR landing page URL' // users will be redirected there after adding your bot app to slack. If not set, they will be redirected to their standard slack chats.\n  },\n  webhookEndpoint: '/webhook',\n  storeTeamInfoInFile: true,\n};\n\nconst botsSettings = [{ telegram: telegramSettings },\n                      { messenger: messengerSettings },\n                      { twitter: twitterSettings },\n                      { slack: slackSettings }];\n\nconst botmasterSettings = {\n  botsSettings: botsSettings,\n  // by default botmaster will start an express server that listens on port 3000\n  // you can pass in a port argument here to change this default setting:\n  port: 3001,\n}\n\nconst botmaster = new Botmaster(botmasterSettings);\n\n// actual code\nbotmaster.on('update', (bot, update) = {\n  bot.sendTextMessageTo('Right back at you!', update.sender.id);\n});\n\nbotmaster.on('error', (bot, err) = {\n  console.log(err.stack);\n  console.log('there was an error');\n});\n",
        "tags": []
    },
    {
        "uri": "/content/getting-started/slack-setup",
        "title": "Slack setup",
        "content": "\nCode\n\nconst Botmaster = require('botmaster');\n\nconst slackSettings = {\n  credentials: {\n    clientId: 'YOUR app client ID',\n    clientSecret: 'YOUR app client secret',\n    verificationToken: 'YOUR app verification Token'\n  },\n  webhookEndpoint: '/webhookd24sr34se',\n  storeTeamInfoInFile: true,\n};\n\nconst botsSettings = [{ slack: slackSettings }];\n\nconst botmaster = new Botmaster({ botsSettings });\n\nbotmaster.on('update', (bot, update) = {\n  bot.reply(update, 'Right back at you');\n});\n The Botmaster Slack bot\n\nBecause Slack works slightly differently from the other platforms covered in the core Botmaster package, I will briefly explain here what your botmaster Slack bot will be exactly.\n\nAs you surely know, Slack is a product that enables team members to communicate easily with one another. because of that, one team member can't just \"add\" a bot for herself in the same way one would in Facebook Messenger or Telegram or other.\n\nTeams can either build a bot that will only live within their own slack team. Or they can package a bot in a Slack app that \"packages\" the bot.\nAdmin team members can add support for a bot (by installing an App that packages said bot) and then team members can start communicating with it as they would with another team member. At this point, they would be communicating with what is known as, in Slack semantics, a bot user.\n\nThe slackSettings object is required to allow us to communicate to end users via this bot user that needs to be set up on Slack's end.\n\nBotmaster Slack bot mini-tutorial\n\nFollowing these steps, you will have a fully functional Slack bot using botmaster that can then be edited as wanted. This mini-tutorial uses localtunnel to expose one of your ports to the world. see why you might want to use this and how to install and setup localtunnel herefor your local botmaster project. You can use ngrok or any other service you know or find suitable and achieve the same result.\n\n Create an app\n\nNavigate to: https://api.slack.com/apps and make sure you are signed in. If you aren't you will be redirected to your team's slack once logged in and will need to go back to the mentioned link.\n\nClick the create new App button and enter any App Name you want. This won't be the name of the bot user. However, the name should ideally be related to your bot user so as not to confuse your users. For instance, if your bot user will be called my_super_bot, calling the app something like My Super Bot App would make sense.\n\nGet your first credentials\n\nOn this page you were redirected to, you will find an App credentials section. Both your Client ID (clientId in Botmaster) and your Client Secret (clientSecret in Botmaster) are here. Take note of them.\n\n Setup Your App's OAuth Webhook\n\nYou don't need to know anything about OAuth to complete this step. Just know that this URL will be called when people are installing/authorizing your app.\n\nIn the left panel, click on the OAuth & Permissions tab and enter your webhook in the Redirect URL(s) field as shown here:\n    \nThis URL has to be of the form: https://\\your_base_url\\/slack/\\webhookEndpoint\\. For example, if I am using localtunnel to test the bot locally, and started localtunnel by running the following:\n   lt -p 3000 -s botmastersubdomain\n I would set my Redirect URL(s) to: https://botmastersubdomain.localtunnel.me/slack/webhookd24sr34se (based on the webhookEnpoint set in my slackSettings at the top of this page). Click on Save Changes.\n\nAdd a Bot User\n\nGo to Bot Users and click on the Add a Bot User button. Select a name for your bot (e.g. mysuperbot) and click the Add Bot User button.\n\n Get the rest of your credentials\n\nNavigate to the Event Subscriptions tab and click on the toggle button in the to right corner to on. Then in the Request URL field that pops up, enter the same URL as in step 4. You will get an error. This is normal and is due to two reasons. Firstly, we don't actually have an app started and listening at the mentioned URL and secondly because even if we did, we don't have our App's verification Token. Let's fix this!\n\nNavigate back to Basic Information and note that you now have a Verification Token in the App Credentials box. Take note of it.\n\nStart your Botmaster App Locally\n\nStart your botmaster app in any project folder you might want (see here if you haven't installed botmaster yet). To start the botmaster project, you'll want to create an app.js file with the contents from the code at the top of this page in the root of your project folder. Replace the credentials with the ones you have gathered. Run node app.js to start the app. Let's now expose out bot to the world.\n\nFor the webhook to work locally, you'll now need to make sure you've started localtunnel. If you are doing all of that from a server that already has a Domain Name, you won't need to do this. But I am assuming most people are doing this from their local computer. so in the command line, run something like this:\nlt -p 3000 -s wantedbaseurlforyour_bot\n\n Setup Your App's Events and Events Webhook\n\nGo back to the Event subscription page and enter your webhook url again. This should now work and look something like this:  Scroll down and click on Add Bot User Events. At the minimum, add the following events:\n    message.ipm\n    message.channels\n    message.im\n    message.groups\nClick Save Changes\n\nInstall your Slack App\n\nWe're almost done here. We need a way to install our app to test it out. This is done via what is called a Slack button. because botmaster manages all the nitty-gritty parts of this process, all you need to do is create a views folder in your project folder and create an index.html file in this views folder with the following contents\na href=\"https://slack.com/oauth/authorize?scope=bot&clientid=YOURAPPCLIENTID\"\n  <img alt=\"Add to Slack\" height=\"40\" width=\"139\"\n  src=\"https://platform.slack-edge.com/img/addtoslack.png\"\n  srcset=\"https://platform.slack-edge.com/img/addtoslack.png 1x,\n          https://platform.slack-edge.com/img/addtoslack@2x.png 2x\" /\n/a\nNote that you'll need to replace YOUR_APP_CLIENT_ID in the href with your own. You definitely don't want to put in your client secret here!\n\n Try out your bot!\n\nAssuming your botmaster app and localtunnel are still running, open your index.html file (not in a text editor, but actually in a browser) by double clicking on it. Authorize your newly created app to add it to your team. You should now be redirected to your teams slack and be able to chat to your bot.\n\nMake your Bot Available to the World\n\nYou might actually want to allow others to install your app by using the Slack Button. However, to do so you will need to host it somewhere. We'll take advantage of the fact that botmaster uses express.js under the hood and edit our app.js file to look like this:\n\nconst Botmaster = require('botmaster');\nconst express = require('express'); // added\n.\n.\n.\nconst botmaster = new Botmaster({ botsSettings });\nbotmaster.app.use(express.static(__dirname + '/views')); //added\n// or if you don't want it at the root of your app, add this:\nbotmaster.app.use('/slack', express.static(__dirname + '/views')); // added\n\nbotmaster.on('update', (bot, update) = {\n  bot.reply(update, 'Right back at you');\n});\n\nMake sure to add either one of the botmaster.app.use... lines.\nIf you pick the first one, navigate to your URL (https://botmastersubdomain.localtunnel.me/ for this example) and you will see the button.\nIf your pick the second one, navigate to your sub URL (https://botmastersubdomain.localtunnel.me/slack for this example) to see the Slack button.\n\n Webhooks\n\nNow as with any other platform using Webhooks, you'll need to update these to your production Domain Name once you deploy your code to production. And in a more general sense, if you are still unsure how webhooks work within the botmaster framework, go here\n",
        "tags": []
    },
    {
        "uri": "/content/getting-started/socketio-setup",
        "title": "Socket.io setup",
        "content": "\nCode\n\n Server\nconst Botmaster = require('botmaster');\n\nconst socketioSettings = {\n  id: 'SOMEIDOFYOURCHOOSING',\n};\n\nconst botsSettings = [{ socketio: socketioSettings }];\n\nconst botmaster = new Botmaster({ botsSettings });\n\nbotmaster.on('update', (bot, update) = {\n  bot.reply(update, 'Right back at you');\n});\n\nClient\nconst io = require('socket.io-client');\n\nconst socket = io(\"ws://localhost:4000\");\n\nsocket.on('connect', function() {\n  const message = {\n    text: 'Hey there botmaster!'\n  };\n\n  socket.send(JSON.stringify(message));\n});\n\n The Botmaster Socket.io bot\n\nSocket.io is a great library that allows developers to write apps using webSockets (with fallbacks to http long-polling and others when webSockets aren't available in the client). You can read more about it on their own website here: http://socket.io.\n\nBecause you might want to have a bot that not only works on some platform but also on your own webapp/app, support for socket.io was added to the Botmaster core. Although Socket.io enables developers to use their technology in a bunch of different applications, the fact that you want to use it in Botmaster means that you want to handle 1-1 conversations between users and your bot (managed by botmaster).\n\nIf you've never used both botmaster and socket.io, It's probably still pretty unclear how all of this fits in together. Hopefully the next section will help you understand and get started with this.\n\nBotmaster Socket.io bot mini-tutorial\n\nBy following these steps, you will have a fully functional Socket.io bot using botmaster. The client will live in a tiny web-page. The point of this tutorial is to get you started so that you can develop it further in any way you wish. This is completely based on the socket.io web \"get started\" guide found here: http://socket.io/get-started/chat/.\n\n Server\n\nAfter making sure that we have a project folder with a node.js project initialised and the botmaster package in it as per the installation guide.\nWe want to make sure botmaster is setup and make sure that messages coming from a websocket connection are received. So in our poject folder, in our app.js file, we simply copy the code found at the top of this page:\n\nconst Botmaster = require('botmaster');\n\nconst socketioSettings = {\n  id: 'SOMEIDOFYOURCHOOSING',\n};\n\nconst botsSettings = [{ socketio: socketioSettings }];\n\nconst botmaster = new Botmaster({ botsSettings });\n\nbotmaster.on('update', (bot, update) = {\n  bot.reply(update, 'Right back at you');\n});\n\nWe will need to add a couple of lines to this code because we will be serving a webpage from our server. Not just listening on for botmaster messages. To do so, we take advantage of the fact that botmaster is built on top of express and that. We also assume that we will be serving our static assets (the components of our webpage) from a folder called 'public' within our project directory. Our updated code looks like this:\n\nconst Botmaster = require('botmaster');\nconst express = require('express'); //added\n\nconst socketioSettings = {\n  id: 'SOMEIDOFYOURCHOOSING',\n};\n\nconst botsSettings = [{ socketio: socketioSettings }];\n\nconst botmaster = new Botmaster({ botsSettings });\nbotmaster.app.use(express.static(__dirname + '/public')); //added\n\nbotmaster.on('update', (bot, update) = {\n  bot.reply(update, 'Right back at you');\n});\n\nbotmaster.on('error', (bot, err) = {\n  console.log(err);\n});\n\nWe also added the botmaster 'error' event listener, because that's just always good to do.\n\nClient side\n\nAs mentioned in the Server side, we will create a folder named 'public' within our poject dir. In it, we will have the following three files:\n\nindex.html\nstyle.css\nclient_app.js\n\nSo that your final tree structure looks like this:\n\nyourprojectfolder\n├── app.js\n└── public\n    ├── client_app.js\n    ├── index.html\n    └── style.css\n\nIn the index.html file, we will put some very basic html that looks like this:\n\n!doctype html\nhtml\n  head\n    titleBotmaster bot/title\n    link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"\n  /head\n  body\n    div class=\"chat\"\n      ul id=\"messages\"/ul\n      form id=\"form\" action=\"\"\n        input type=\"text\" id=\"text-input\" autocomplete=\"off\" /buttonSend/button\n      /form\n    /div\n\n    script src=\"/socket.io/socket.io.js\"/script\n    script src=\"client_app.js\"/script\n  /body\n/html\n\nThe important line here is the line where we are importing socket.io. This works because socket.io adds a path to our server (in this case, a server created by botmaster under the hood) to serve this exact endpoint.\nThe other imports are simply the ones we will be creating.\n\nIn the style.css file, simply add the following:\n\n{\n  margin: 0;\n  padding: 0;\n  box-sizing:\n  border-box;\n}\n\nbody {\n  font: 13px Helvetica, Arial;\n}\n\nform {\n  background: 000;\n  padding: 3px;\n  position: fixed;\n  bottom: 0;\n  width: 100%;\n}\n\nform input {\n  border: 0;\n  padding: 10px;\n  width: 90%;\n  margin-right: .5%;\n}\n\nform button {\n  width: 9%; background: rgb(130, 224, 255);\n  border: none; padding: 10px;\n}\n\nmessages {\n  list-style-type: none;\n  margin: 0;\n  padding: 0;\n}\n\nmessages li {\n  padding: 5px 10px;\n}\n\nmessages .botmaster-message {\n  background: eee;\n}\nThis is the exact look from the socket.io tutorial mentioned above (and mostly their code too).\n\nFinally, in the client_app.js file, you should include the following:\n\n// the following line could also be: \"var socket = io('');\"\n// if you know you are communicating with the same server that served you the page you are on\nvar socket = io(\"ws://localhost:3000\");\n\n// just get the html elements we will be needing by ID\nvar form = document.getElementById('form');\nvar textInput = document.getElementById('text-input');\nvar messages = document.getElementById('messages');\n\nform.onsubmit = function(event) {\n  // just making sure the page isn't refreshed\n  event.preventDefault();\n  // don't do anything if there is no text\n  if (!textInput.value) {\n    return;\n  }\n  // Add the user message to the web page\n  messages.insertAdjacentHTML('beforeend',\n    li class=\"user-message\"${textInput.value}/li);\n  // create a botmaster compatible message from the text input by user\n  const message = {\n    text: textInput.value,\n  };\n  // just send a stringified version of it over the webSocket\n  socket.send(JSON.stringify(message));\n  // finally, clear the user textInput field\n  textInput.value = '';\n};\n\nsocket.on('message', function(botmasterMessage){\n  var messageObject = JSON.parse(botmasterMessage);\n  var textMessage = messageObject.message.text;\n\n  messages.insertAdjacentHTML('beforeend',\n    li class=\"botmaster-message\"${textMessage}/li);\n});\n\nYou should have a read through this code to make sure you understand it as that is the code communicating with our botmaster backend.\n\nIn the form.onsubmit part, we make sure that the text contained in the input cell is correctly formatted then sent to botmaster via the websocket. We also make sure to display it in our page and to then clear the input.\n\nIn the socket.on('message') part, we simply display the received message.\n\nNow that our code is here, simply go to your command line and run node app.js. If you now open a browser to 127.0.0.1:3000 you should be able to chat with your pretty useless (for now) bot. Just like this:\n\n",
        "tags": []
    },
    {
        "uri": "/content/getting-started/telegram-setup",
        "title": "Telegram setup",
        "content": "\nCode\n\nconst Botmaster = require('botmaster');\n\nconst telegramSettings = {\n  credentials: {\n    authToken: 'YOUR authToken',\n  },\n  webhookEndpoint: '/webhook1234/',\n};\n\nconst botsSettings = [{ telegram: telegramSettings }];\n\nconst botmaster = new Botmaster({ botsSettings });\n\nbotmaster.on('update', (bot, update) = {\n  bot.reply(update, 'Right back at you');\n});\n\n Credentials\n\nAll you need here is an authToken. In order to get one, you will need to either create a new bot on telegram.\n\nBasically, you'll need to send a /newbot command(message) to Botfather (go talk to him here). Once you're done with giving it a name and a username, BotFather will come back to you with your authToken. Make sure to store it somewhere. More info on BotFather can be found here if needed.\n\nFor more on Telegram, you can find the telegram api docs here\n\nWebhooks\n\nSetting up your webhook requires you to make the following request outside of Botmaster (using curl for instance or a browser):\n\nhttps://api.telegram.org/botauthToken/setWebhook?url='Your Base URL'/telegram/webhook1234\n\n{{% notice warning %}}\nBecause Telegram doesn't send any type of information to verify the identity of the origin of the update, it is highly recommended that you include a sort of hash in your webhookEndpoint. I.e., rather than having this: webhookEndpoint: '/webhook/', do something more like this: webhookEndpoint: '/webhook92ywrnc9qm4qoiuthecvasdf42FG/'. This will assure that you know where the request is coming from.\n{{% /notice %}}\n\n{{% notice note %}}\nIf you are not too sure how webhooks work and/or how to get them to run locally, go to webhooks to read some more.\n{{% /notice %}}\n",
        "tags": []
    },
    {
        "uri": "/content/getting-started/twitter-setup",
        "title": "Twitter setup",
        "content": "\n\nconst Botmaster = require('botmaster');\n\nconst twitterSettings = {\n  credentials: {\n    consumerKey: 'YOUR consumerKey',\n    consumerSecret: 'YOUR consumerSecret',\n    accessToken: 'YOUR accessToken',\n    accessTokenSecret: 'YOUR accessTokenSecret',\n  }\n}\n\nconst botsSettings = [{ twitter: twitterSettings }];\n\nconst botmaster = new Botmaster({ botsSettings });\n\nbotmaster.on('update', (bot, update) = {\n  bot.reply(update, 'Right back at you');\n});\n\nGetting your Credentials\n\nTwitter's setup is slightly more tricky than one would wish. Because Twitter requires you to create an actual account and not a page or a bot, you'll have to do a few more steps.\n\n Setting up the bot account\n\nJust create a standard twitter account as you would any other. Name it as you want.\nnavigate to your security and privacy settings (click on your image profile  settings  privacy and security settings)\nscroll to the bottom of the page and make sure \"Receive Direct Messages from anyone\" is ticked. (currently this has to be done because of Twitter's rules concerning DMs, where in order to send a DM to someone, they have to be following you).\n\nSetting up the app\n\nNavigate to the somewhat hard to find Twitter developer app dashboard at: https://apps.twitter.com/\nClick Create New App. Enter your details (callback URL is not required if you are starting from scratch here). 'Website' can take in a placeholder like (http://www.example.com)\nNow navigate straight to the 'Permissions' tab(do this before going to the 'Keys and Access Tokens' tab). Select 'Read, Write and Access direct messages' and then click 'Update Setting'\nNavigate to the 'Keys and Access Tokens' tab. You'll find your consumerKey and consumerSecret right here\nScroll down and click on 'Create my access token'. You now have your accessToken  and your accessTokenSecret\n\n! Makes sure not to create your access token before having reset your permissions. If you do that, you will need to change your permissions then regenerate your access token.\n\nThat should about do it. Because twitter DM is not completely separate from the rest of Twitter, it behaves quite differently from the other platforms on many aspects. These points are covered in working with botmaster.\n",
        "tags": []
    },
    {
        "uri": "/content/home/index",
        "title": "Botmaster v 2.1.1",
        "content": "\nWhat is botmaster?\n\nBotmaster is a lightweight highly extendable, highly configurable chatbot framework. It was meant to be used both in small scale and large scale projects. Its purpose is to integrate your chatbot into a variety of messaging channels - currently Facebook Messenger, Slack, Twitter DM, Telegram and socket.io. Using botmaster looks something like this:\n\nconst Botmaster = require('botmaster');\nconst config = require(./config);\nconst botsSettings = [{ telegram: config.telegramSettings },\n                      { messenger: config.messengerSettings },\n                      { twitter: config.twitterSettings },\n                      { slack: config.slackSettings }];\n\nconst botmasterSettings = { botsSettings };\n\nconst botmaster = new Botmaster(botmasterSettings);\n\nbotmaster.on('update', (bot, update) = {\n  bot.reply(update, 'Right back at you!');\n});\n\n Botmaster is platform agnostic\n\nBotmaster is platform agnostic in two important ways. Firstly, out of the box, developers can have bots running on Facebook Messenger, Slack, Twitter DM, Telegram and their personal webapp/app via socket.io with not only a standardized text message format, but also a standardized attachment format. Secondly, BotMaster makes no assumptions about the back-end bot itself - you can write code that allows BotMaster to call conversational engines such as IBM Watson's conversation API, open source frameworks or even write the conversation engine yourself.\n\nBotmaster's Philosophy\n\nIts philosophy is to minimise the amount of code developers have to write in order to create 1-on-1 conversational chatbots that work on multiple platforms. It does so by defining a standard with respect to what format messages take and how 1-on-1 conversations occur. Messages to/from the various messaging channels supported are all mapped onto this botmaster standard, meaning the code you write is much reduced when compared to a set of point:point integrations.\n",
        "tags": []
    },
    {
        "uri": "/content/working-with-botmaster/botmaster-basics",
        "title": "Botmaster Basics",
        "content": "\nHopefully by now, you've gathered your credentials for at least one platform and got some basic bot running.\nNow that you have your settings, you can go ahead and create a botmaster object. This essentially 'starts' botmaster. Briefly rehearsing what was mentioned in the 'Getting set up' section, doing so will look a little something like this:\n\nconst Botmaster = require('botmaster');\n\nconst botsSettings = [{ messenger: messengerSettings },\n                      { twitter: twitterSettings },\n                      { telegram: telegramSettings }];\n\nconst botmasterSettings = {\n  botsSettings: botsSettings,\n  // by default botmaster will start an express server that listens on port 3000\n  // you can pass in a port argument here to change this default setting:\n  port: 3001\n}\n\nconst botmaster = new Botmaster(botmasterSettings);\n\nWhere our platform-specific settings have been taken from the \"Getting set up\"\n step.\n\nSettings\n\nThe botmasterSettings object has the following parameters:\n\n| Parameter | Description\n|--- |---\n| botsSettings | An array of platform specific settings. See Getting set up for more info on that\n| port  | (optional) The port to use for your webhooks (see webhooks to understand more about webhooks). This will only be used if the app parameter is not provided. Otherwise, it will be ignored\n| app  | (optional) An express.js app object to mount the webhookEnpoints onto. If you choose to do this, it is assumed that you will be starting your own express server and this won't be done by Botmaster.\n| sessionStore | (optional) a sessionStore object to store basic context and information about the bot and the updates it receives. See the session section below to read more about sessions\n\n Events\n\nBotmaster is built on top of the EventEmitter node.js class. Which means it can emit events and most importantly for us here, it can listen onto them. By doing the following:\n\nbotmaster.on('update', (bot, update) = {\n  console.log(bot.type);\n  console.log(update);\n});\n\nbotmaster.on('error', (bot, err) = {\n  console.log(bot.type);\n  console.log(err.stack);\n});\n\nI am registering two new listeners onto the botmaster object. One that listens for any updates that come in and one that listens for any potential error that might occur when receiving updates. The update events is of course the one you will want to focus most of your attention onto. You see here that every update event will come with a bot and an update object as arguments. This will always be the case. In general, the updates are standardized as well as the methods to use from the bot object (i.e. sending a message).\n\nBot object\n\nEvery Botmaster instance will have a list of bots that can be accessed by calling: botmaster.bots assuming your Botmaster instance is named 'botmaster'.\n\nBot instances can be accessed through that array or more commonly, directly within an update event. Because you might want to act differently on bots of a certain type or log information differently based on type, every bot comes with a bot.type parameter that is one of: messenger, twitter or telegram (for now). Use these to write more platform specific code (if necessary).\n\nI'll note quickly that each bot object created comes from one of the TelegramBot, MessengerBot or Twitterbot classes. They act in the same way on the surface (because of heavy standardization), but have a few idiosynchrasies here and there.\n\nYou can also create bot objects directly from their base classes. Here is an example of creating a twitter bot.\n\nconst TwitterBot = require('botmaster').botTypes.TwitterBot;\n\nconst twitterSettings = {\n    consumerKey: 'YOUR consumerKey',\n    consumerSecret: 'YOUR consumerSecret',\n    accessToken: 'YOUR accessToken',\n    accessTokenSecret: 'YOUR accessTokenSecret',\n  }\n}\n\ntwitterBot = new TwitterBot(twitterSettings);\n\nAll bot items are also of the EventEmitters class. So you will be able to do something like this:\n\ntwitterBot.on('update', (update) = {\n  console.log(update);\n})\n\nThe update object will be of the same format as the ones you'll get using botmaster.on('update', ...).\n\nIf for some reason you created a bot this way but now want it to be in a botmaster object, you can do this easily this way:\n\nbotmaster.addBot(twitterBot);\nThis is important if you create your own Bot that extends the Botmaster.botTypes.BaseBot class. For instance, you might want to create your own class that supports your pre-existing messaging standards. Have a look at the writinga_botmastersupported_bot-class.md file to learn how to do this.\n",
        "tags": []
    },
    {
        "uri": "/content/working-with-botmaster/index",
        "title": "Working with Botmaster",
        "content": "\nWorking with Botmaster\n",
        "tags": []
    }
]